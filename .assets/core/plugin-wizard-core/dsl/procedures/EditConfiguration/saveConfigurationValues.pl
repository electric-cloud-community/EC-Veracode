use strict;
use warnings;
## === createConfiguration template ===
# Please do not edit this file
use ElectricCommander;
use ElectricCommander::PropDB;
use JSON;
use Data::Dumper;
# exit 0;
use constant {
    SUCCESS => 0,
    ERROR   => 1,
};
local $| = 1;

my $projName = '@PLUGIN_KEY@-@PLUGIN_VERSION@';
my $ec = ElectricCommander->new();


# Checking system for external credentials support. If there is no support, we're just exiting and
# giving control to the EC-PluginManager.
if (!does_system_has_support_of_external_credentials()) {
    print "Handing control over to the EC-PluginManager\n";
    exit 0;
}
my $configPropertySheet;
eval {
    $configPropertySheet = $ec->getPropertyValue('/myProject/ec_configPropertySheet');
    1;
} or do {
    $configPropertySheet = 'ec_plugin_cfgs';
};

my $steps = [];
my $stepsJSON = eval {
    $ec->getPropertyValue("/projects/$projName/procedures/CreateConfiguration/ec_stepsWithAttachedCredentials")
};
if ($stepsJSON) {
    $steps = decode_json($stepsJSON);
}

my $opts = getActualParameters();

my $configuration_name = $opts->{config};
my $configName = $configuration_name;


# 1. Check whether configuration property sheet exists. Procedure should be failed if it does not.

my $propertySheetFullPath = '/projects/' . $projName . '/' . $configPropertySheet . '/' . $configuration_name;

eval {
    $ec->getPropertyValue($propertySheetFullPath);
    1;
} or do {
    print "Config property sheet $propertySheetFullPath does not exist. Can't edit.\n";
    exit 1;
};

# now we have a path to the propety sheet where our config is stored.
# we're handling properties, credentials will go next.

for my $k (keys %$opts) {
    if ($k =~ m/_?credential$/s) {
        my $key_ref = $k . '_ref';
        unless ($opts->{$key_ref}) {
            my $generated_cred_name = gen_credential_name($configuration_name, $k);
            $ec->setProperty("$propertySheetFullPath/$k", gen_credential_name($configuration_name, $k));
            $ec->getPropertyValue("$propertySheetFullPath/$k");
        }
        else {
            # it has the credential reference, so the runtime credential should be deleted.
            my $credential_to_delete =  gen_credential_name($configuration_name, $k);
            $ec->deleteCredential($projName, $credential_to_delete);
            $ec->setProperty("$propertySheetFullPath/$k", $opts->{$key_ref});
        }
        next;
    }
    my $propPath = $propertySheetFullPath . '/' . $k;
    $ec->setProperty($propPath, $opts->{$k});
}

# deleting ref keys
for my $k (keys %$opts) {
    if ($k =~ m/credential_ref$/s) {
        $ec->deleteProperty("$propertySheetFullPath/$k");
    }
}

eval {
    my $opts = getActualParameters();
    for my $param ($ec->getFormalParameters({
        projectName => $projName,
        procedureName => 'CreateConfiguration',
    })->findnodes('//formalParameter')) {
        my $type = $param->findvalue('type') . '';
        if ($type eq 'credential') {
            my $required = $param->findvalue('required') . '';
            my $fieldName = $param->findvalue('formalParameterName') . '';
            my $credentialName = $opts->{$fieldName};

            eval {
                my $ref = createAndAttachCredential($credentialName, $configName, $configPropertySheet, $steps);
                1;
            } or do {
                my $err = $@;
                if ($required) {
                    die $err;
                }
                else {
                    print "Failed to create credential $credentialName: $err\n";
                }
            };
        }
    }
    1;
} or do {
    my $err = $@;
    print $err;
    rollback($configPropertySheet, $err);
    $ec->setProperty("/myJob/configError", $err);
    exit 1;
};


# Handling credentials here
### Service subroutines

sub getActualParameters {
    my $x       = $ec->getJobDetails($ENV{COMMANDER_JOBID});
    my $nodeset = $x->find('//actualParameter');
    my $opts;

    foreach my $node ($nodeset->get_nodelist) {
        my $parm = $node->findvalue('actualParameterName');
        if ($parm =~ m/credential$/s) {
            my $credRef = getCredentialReference($parm);
            if ($credRef) {
                my $key = $parm . '_ref';
                $opts->{$key} = $credRef;
            }
        }
        my $val  = $node->findvalue('value');
        $opts->{$parm} = "$val";
    }
    return $opts;
}


sub getCredentialReference {
    my ($credName) = @_;

    if (!$credName) {
        die "Cred name is mandatory to get credential reference...\n";
    }
    my $xpath = $ec->getFullCredential($credName);
    my $existingCredRef = undef;
    eval {
        $existingCredRef = $xpath->findvalue("//credentialReference")->string_value();
    };

    return $existingCredRef;
}


sub createAndAttachCredential {
    my ($credName, $configName, $configPropertySheet, $steps) = @_;

    my $xpath = $ec->getFullCredential($credName);
    my $errors = $ec->checkAllErrors($xpath);

    my $clientID = $xpath->findvalue("//userName");
    my $clientSecret = $xpath->findvalue("//password");
    my ($existingCredRef, $existingCredProjectName, $existingCredName);
    eval {
        $existingCredRef = $xpath->findvalue("//credentialReference")->string_value();
        $existingCredName = $xpath->findvalue("//credentialName")->string_value();
        # here we have the credential that has been passed as a reference.
        $existingCredProjectName = $1 if $existingCredRef =~ m|\/projects\/(.*?)\/|s;
        # now we have all three of them. And if these values are defined - we have
        # existing credential that we just need to attach instead of create.
    };
    my $projName = '$[/myProject/projectName]';

    my $credObjectName = $credName eq 'credential' ? $configName : "${configName}_${credName}";

    my $configPath = "/projects/$projName/$configPropertySheet/$configName/$credName";
    if (!$existingCredRef) {
        print "Credential reference is not present. Creating runtime credential.\n";
        # Create credential
        $ec->deleteCredential($projName, $credObjectName);
        $xpath = $ec->createCredential($projName, $credObjectName, $clientID, $clientSecret);
        $errors .= $ec->checkAllErrors($xpath);

        # Give job launcher full permissions on the credential
        my $user = '$[/myJob/launchedByUser]';
        $xpath = $ec->createAclEntry("user", $user, {
            projectName => $projName,
            credentialName => $credObjectName,
            readPrivilege => 'allow',
            modifyPrivilege => 'allow',
            executePrivilege => 'allow',
            changePermissionsPrivilege => 'allow'
        });
        $errors .= $ec->checkAllErrors($xpath);
    }
    # Attach credential to steps that will need it
    for my $step( @$steps ) {
        if ($existingCredRef) {
            $credObjectName = $existingCredRef;
        }
        print "Attaching credential to procedure " . $step->{procedureName} . " at step " . $step->{stepName} . "\n";
        my $apath = $ec->attachCredential(
            $projName,
            $credObjectName, {
                procedureName => $step->{procedureName},
                stepName => $step->{stepName}
            });
        $errors .= $ec->checkAllErrors($apath);
    }

    if ("$errors" ne "") {
        # Cleanup the partially created configuration we just created
        $ec->deleteProperty($configPath);
        $ec->deleteCredential($projName, $credObjectName);
        my $errMsg = "Error creating configuration credential: " . $errors;
        $ec->setProperty("/myJob/configError", $errMsg);
        die $errMsg;
    }
}

sub gen_credential_name {
    my ($config_name, $credential_name) = @_;

    if ($credential_name eq 'credential') {
        return $config_name;
    }

    return $config_name . '_' . $credential_name;
}

sub get_ec_plugin_manager_version {
    # my ($ec) = @_;

    my $plugins = $ec->getPlugin('EC-PluginManager');

    my $nodeset = $plugins->find('//plugin');

    my $version = '';
    for my $node ($nodeset->get_nodelist) {
        my $promoted = $node->findvalue('//promoted')->string_value();
        if ($promoted && $promoted eq '1') {
            $version = $node->findvalue('//pluginVersion')->string_value();
        }
    }

    return $version;
}

### Code from Version::Compare by Dominik Schulz.
sub version_compare {
    my $ver1 = shift || 0;
    my $ver2 = shift || 0;
    my @v1 = split /[.+:~-]/, $ver1;
    my @v2 = split /[.+:~-]/, $ver2;

    for ( my $i = 0 ; $i < max( scalar(@v1), scalar(@v2) ) ; $i++ ) {

        # Add missing version parts if one string is shorter than the other
        # i.e. 0 should be lt 0.2.1 and not equal, so we append .0
        # -> 0.0.0 <=> 0.2.1 -> -1
        push( @v1, 0 ) unless defined( $v1[$i] );
        push( @v2, 0 ) unless defined( $v2[$i] );
        if ( int( $v1[$i] ) > int( $v2[$i] ) ) {
            return 1;
        }
        elsif ( int( $v1[$i] ) < int( $v2[$i] ) ) {
            return -1;
        }
    }
    return 0;
}

sub max {
    my $x = shift;
    my $y = shift;
    return ( $x > $y ? $x : $y );
}
### End of code from Version::Compare by Dominik Schulz.

sub does_system_has_support_of_external_credentials {
    my $min_plugin_manager_version_for_external_creds = '1.8.0.0';
    my $current_plugin_manager_version = get_ec_plugin_manager_version();

    my $compare_res = version_compare(
        $current_plugin_manager_version, $min_plugin_manager_version_for_external_creds
    );
    if ($compare_res >= 0) {
        return 1;
    }
    return 0;
}
